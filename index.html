<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#DD8566">
    <title>Terra Cotta Game Suite</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22><rect x=%2210%22 y=%2210%22 width=%2244%22 height=%2244%22 rx=%228%22 fill=%22none%22 stroke=%22%23DD8566%22 stroke-width=%224%22/><circle cx=%2222%22 cy=%2222%22 r=%224%22 fill=%22%23474D4D%22/><circle cx=%2242%22 cy=%2222%22 r=%224%22 fill=%22%23474D4D%22/><path d=%22M20 40 Q32 50 44 40%22 stroke=%22%23474D4D%22 stroke-width=%224%22 fill=%22none%22 stroke-linecap=%22round%22/></svg>">

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700;900&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg: #FFFFFF;
            --text: #474D4D;
            --primary: #DD8566;
            --surface: #F5F5F5;
            --outline: #DBDCDF;
            --radius-btn: 12px;
            --radius-card: 16px;
            --shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        body {
            font-family: 'Roboto', sans-serif; background-color: var(--bg); color: var(--text);
            margin: 0; display: flex; flex-direction: column; align-items: center; min-height: 100vh;
            padding: 20px; box-sizing: border-box; overflow-x: hidden; -webkit-tap-highlight-color: transparent;
            /* Prevent bounce scroll on mobile */
            overscroll-behavior: none;
        }

        /* --- GLOBAL UI --- */
        h1 { margin: 0 0 20px 0; letter-spacing: -0.5px; font-weight: 900; color: var(--text); text-transform: uppercase; }
        .sub-title { color: #999; margin-bottom: 30px; font-weight: 500; }

        .screen { display: none; width: 100%; max-width: 600px; flex-direction: column; align-items: center; animation: fadeIn 0.3s ease-out; }
        .active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        button {
            padding: 12px 24px; font-family: 'Roboto', sans-serif; font-size: 1rem; font-weight: 700;
            background-color: var(--bg); border: 2px solid var(--outline); color: var(--text);
            border-radius: var(--radius-btn); cursor: pointer; transition: all 0.2s; box-shadow: var(--shadow);
            margin: 5px; min-width: 120px;
        }
        button:hover { border-color: var(--primary); color: var(--primary); transform: translateY(-2px); }
        button:active { transform: scale(0.98); }
        
        .btn-primary { background-color: var(--primary); color: white; border-color: var(--primary); }
        .btn-primary:hover { background-color: #c07055; color: white; }

        .back-btn { margin-top: 30px; background: transparent; border: none; color: #999; box-shadow: none; text-decoration: underline; font-weight: 400; }
        .back-btn:hover { background: transparent; color: var(--primary); transform: none; }

        /* --- HUB GRID --- */
        .hub-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; width: 100%; max-width: 500px; }
        .hub-card {
            background: var(--surface); padding: 30px 20px; border-radius: var(--radius-card);
            text-align: center; cursor: pointer; transition: 0.2s; border: 2px solid transparent;
            display: flex; flex-direction: column; align-items: center; gap: 10px;
        }
        .hub-card:hover { border-color: var(--primary); background: #fff; transform: translateY(-3px); box-shadow: var(--shadow); }
        .hub-icon { font-size: 2.5rem; color: var(--primary); margin-bottom: 5px; }
        .hub-title { font-weight: 700; color: var(--text); }

        /* --- GENERIC GAME CANVAS --- */
        canvas {
            background: var(--surface); border-radius: var(--radius-card);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
            max-width: 100%; margin-top: 10px;
            /* CRITICAL: Prevents page scrolling when touching the canvas */
            touch-action: none; 
        }
        .score-display { font-size: 2rem; font-weight: 900; color: var(--primary); margin: 10px 0; font-family: 'Roboto Mono', monospace; }

        /* --- MINESWEEPER STYLES --- */
        #ms-board { display: grid; gap: 2px; background: var(--outline); padding: 2px; border-radius: 8px; margin-top: 10px; user-select: none; -webkit-user-select: none; }
        .ms-cell {
            width: 30px; height: 30px; background: var(--bg); display: flex; align-items: center; justify-content: center;
            font-weight: bold; cursor: pointer; user-select: none; font-family: 'Roboto Mono'; font-size: 1.2rem;
        }
        .ms-cell.revealed { background: #e5e5e5; color: var(--text); }
        .ms-cell.bomb { background: var(--text); color: white; }
        .ms-cell.flag { color: var(--primary); }
        
        /* --- TIC TAC TOE SPECIFIC --- */
        #game-wrapper { position: relative; margin-top: 10px; transition: transform 0.5s; width: 100%; display: flex; justify-content: center; }
        
        /* SVG LINE OVERLAY */
        #win-line-svg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100; overflow: visible;
            filter: drop-shadow(0px 4px 6px rgba(0,0,0,0.3));
        }
        .win-path {
            stroke: var(--primary); stroke-width: 16; stroke-linecap: round;
            fill: none; opacity: 0.9; stroke-dasharray: 1000; stroke-dashoffset: 1000;
            animation: drawLine 0.6s forwards cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        @keyframes drawLine { to { stroke-dashoffset: 0; } }

        .ttt-btn-group { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin: 15px 0; }
        .ttt-cell {
            display: flex; align-items: center; justify-content: center; font-weight: 700; cursor: pointer;
            background: var(--bg); transition: 0.2s; border-radius: 4px; position: relative; z-index: 2;
        }
        .ttt-cell.x { color: var(--text); } .ttt-cell.o { color: var(--primary); }
        .ttt-cell.highlight { background-color: #FFDBCF !important; transition: background 0.5s; }

        #board-normal { display: grid; grid-template-columns: repeat(3, 80px); grid-template-rows: repeat(3, 80px); gap: 4px; background: var(--outline); padding: 4px; border-radius: 12px; }
        #board-normal .ttt-cell { font-size: 3rem; }

        /* 3D Board */
        #board-3d { 
            perspective: 1000px; 
            margin-top: 40px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding-bottom: 50px; 
        }

        .layer-3d { 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            gap: 4px; 
            /* Isometric-ish stack transform */
            transform: rotateX(60deg) rotateZ(-45deg); 
            margin-bottom: -40px; /* Stack overlap */
            transition: transform 0.3s ease;
            
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--outline);
            padding: 6px;
            border-radius: 6px;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.05);
        }

        /* Lift layer on hover for better visibility */
        .layer-3d:hover {
            transform: rotateX(60deg) rotateZ(-45deg) translateZ(15px);
            z-index: 10;
            border-color: var(--primary);
        }

        #board-3d .ttt-cell { 
            width: 50px; 
            height: 50px; 
            font-size: 1.5rem; 
            border: 1px solid #eee; 
            background: rgba(245,245,245,0.5);
            /* Counter rotate text so it looks upright */
            display: flex; align-items: center; justify-content: center;
        }
        
        #board-3d .ttt-cell span { transform: rotateZ(45deg); display:block; }

        /* Ultimate Board */
        #board-ultimate { display: grid; grid-template-columns: repeat(3, auto); gap: 6px; background: var(--text); padding: 6px; border-radius: 12px; }
        .sub-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; background: var(--outline); padding: 2px; position: relative; }
        .sub-grid.active-zone { background: #FFDBCF; }
        .sub-grid.won-x::after { content: "X"; position: absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size: 80px; color: var(--text); opacity: 0.8; }
        .sub-grid.won-o::after { content: "O"; position: absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size: 80px; color: var(--primary); opacity: 0.8; }
        .sub-grid.won-x .ttt-cell, .sub-grid.won-o .ttt-cell { opacity: 0.1; }
        #board-ultimate .ttt-cell { width: 32px; height: 32px; font-size: 1rem; background: var(--bg); }

        /* Toggles & Codes */
        .toggle-wrapper { display: flex; align-items: center; gap: 10px; margin-top: 10px; font-size: 0.9rem; color: #777; justify-content: center;}
        .switch { position: relative; display: inline-block; width: 40px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(16px); }

        .code-box { background: var(--surface); padding: 10px; font-family: monospace; font-size: 1.5rem; border: 2px dashed var(--outline); color: var(--primary); margin: 10px; user-select: all; cursor: pointer; }
        input.mp-input { padding: 10px; border: 2px solid var(--outline); border-radius: 8px; text-align: center; font-size: 1.2rem; width: 200px; text-transform: uppercase; }

        /* Modal */
        .modal-overlay { position: fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:2000; display:none; justify-content:center; align-items:center; }
        .modal { background:white; padding:30px; border-radius:16px; max-width:400px; width:90%; text-align:center; }

        @media (max-width: 600px) {
            #board-normal { grid-template-columns: repeat(3, 70px); grid-template-rows: repeat(3, 70px); }
            #board-normal .ttt-cell { font-size: 2.5rem; }
        }
    </style>
</head>
<body>

    <div id="screen-hub" class="screen active">
        <h1>Terra Cotta Suite</h1>
        <div class="sub-title">Select a Game</div>
        
        <div class="hub-grid">
            <div class="hub-card" onclick="Suite.loadGame('ttt')">
                <div class="hub-icon">âœ•</div>
                <div class="hub-title">Tic-Tac-Toe</div>
            </div>
            <div class="hub-card" onclick="Suite.loadGame('snake')">
                <div class="hub-icon">S</div>
                <div class="hub-title">Snake</div>
            </div>
            <div class="hub-card" onclick="Suite.loadGame('mines')">
                <div class="hub-icon">M</div>
                <div class="hub-title">Minesweeper</div>
            </div>
            <div class="hub-card" onclick="Suite.loadGame('dino')">
                <div class="hub-icon">D</div>
                <div class="hub-title">Dino Run</div>
            </div>
            <div class="hub-card" onclick="Suite.loadGame('pacman')">
                <div class="hub-icon">P</div>
                <div class="hub-title">Pac-Man</div>
            </div>
        </div>
    </div>

    <div id="screen-snake" class="screen">
        <h1>Snake</h1>
        <div class="score-display" id="snake-score">0</div>
        <canvas id="snake-canvas" width="300" height="300"></canvas>
        <div style="margin-top:15px; color:#999; font-size:0.9rem;">Swipe or Arrow Keys to Move</div>
        <button class="btn-primary" onclick="SnakeGame.start()" style="margin-top:20px;">Restart</button>
        <button class="back-btn" onclick="Suite.goHome()">Exit to Hub</button>
    </div>

    <div id="screen-mines" class="screen">
        <h1>Minesweeper</h1>
        <div class="btn-group">
            <button onclick="MinesGame.init('easy')">Easy</button>
            <button onclick="MinesGame.init('hard')">Hard</button>
        </div>
        <div id="ms-board"></div>
        <div style="margin-top:10px; color:#999; font-size:0.9rem;">Click to Reveal â€¢ Long Press/Right Click to Flag</div>
        <button class="back-btn" onclick="Suite.goHome()">Exit to Hub</button>
    </div>

    <div id="screen-dino" class="screen">
        <h1>Dino Run</h1>
        <div class="score-display" id="dino-score">0</div>
        <canvas id="dino-canvas" width="600" height="200"></canvas>
        <div style="margin-top:15px; color:#999; font-size:0.9rem;">Tap or Spacebar to Jump</div>
        <button id="dino-start-btn" class="btn-primary" onclick="DinoGame.start()" style="margin-top:20px;">Start Run</button>
        <button class="back-btn" onclick="Suite.goHome()">Exit to Hub</button>
    </div>

    <div id="screen-pacman" class="screen">
        <h1>Pac-Man Lite</h1>
        <div class="score-display" id="pac-score">0</div>
        <canvas id="pac-canvas" width="300" height="300"></canvas>
        <div style="margin-top:15px; color:#999; font-size:0.9rem;">Swipe or Arrow Keys</div>
        <button class="btn-primary" onclick="PacGame.start()" style="margin-top:20px;">Restart</button>
        <button class="back-btn" onclick="Suite.goHome()">Exit to Hub</button>
    </div>

    <div id="screen-ttt" class="screen">
        <h1>Tic-Tac-Toe</h1>
        
        <div id="ttt-menu">
            <div class="btn-group">
                <button onclick="TTT.setup('local')">Pass & Play</button>
                <button onclick="TTT.setup('bot-diff')">vs Bot</button>
                <button onclick="TTT.setup('mp')">Multiplayer</button>
            </div>
            
            <div class="toggle-wrapper">
                <label class="switch"><input type="checkbox" id="anim-toggle" checked><span class="slider"></span></label>
                <span>Cinematic Win Effects</span>
            </div>

            <button class="back-btn" onclick="Suite.goHome()">Exit to Hub</button>
        </div>

        <div id="ttt-bot-diff" style="display:none; text-align:center;">
            <h3>Bot Difficulty</h3>
            <div class="btn-group">
                <button onclick="TTT.setDifficulty('easy')">Easy</button>
                <button onclick="TTT.setDifficulty('medium')">Medium</button>
                <button onclick="TTT.setDifficulty('hard')">Hard</button>
            </div>
            <button class="back-btn" onclick="TTT.showMenu()">Back</button>
        </div>

        <div id="ttt-mp-setup" style="display:none; text-align:center;">
            <h3>Multiplayer</h3>
            <input type="text" id="mp-name" class="mp-input" placeholder="Your Name" value="Player">
            <div style="margin:20px 0;">
                <button onclick="TTT.host()">Host Game</button>
                <p style="color:#999; margin:10px;">- OR -</p>
                <input type="text" id="join-code" class="mp-input" placeholder="9-CHAR CODE" maxlength="9">
                <br><br>
                <button onclick="TTT.join()">Join Game</button>
            </div>
            <button class="back-btn" onclick="TTT.showMenu()">Back</button>
        </div>

        <div id="ttt-host-wait" style="display:none; text-align:center;">
            <h3>Waiting...</h3>
            <div id="host-code" class="code-box" onclick="TTT.copyLink()">Generating...</div>
            <div style="color:#999; font-size:0.8rem">Tap to Copy Link</div>
            <div id="host-status" style="margin-top:20px; color:var(--primary)">Waiting for player...</div>
            <button class="back-btn" onclick="TTT.showMenu()">Cancel</button>
        </div>

        <div id="ttt-variant" style="display:none; text-align:center;">
            <h3>Select Mode</h3>
            <div class="ttt-btn-group">
                <button onclick="TTT.startGame('normal')">3x3</button>
                <button onclick="TTT.startGame('3d')">3D</button>
                <button onclick="TTT.startGame('ultimate')">Ultimate</button>
            </div>
            <button class="back-btn" onclick="TTT.showMenu()">Back</button>
        </div>

        <div id="ttt-game" style="display:none; width:100%; display:flex; flex-direction:column; align-items:center;">
            <div id="ttt-scoreboard" style="display:flex; gap:20px; margin-bottom:15px; font-weight:bold;">
                <span id="p1-score">P1: 0</span>
                <span id="p2-score">P2: 0</span>
            </div>
            <div id="ttt-turn" style="color:var(--primary); font-weight:bold; margin-bottom:15px;">Turn: X</div>
            
            <div id="game-wrapper">
                <svg id="win-line-svg"></svg>
                <div id="ttt-board-container"></div>
            </div>

            <button id="ttt-restart" class="btn-primary" style="margin-top:20px; display:none;" onclick="TTT.restart()">Next Round</button>
            <button class="back-btn" onclick="TTT.showMenu()">End Game</button>
        </div>
    </div>

    <div class="modal-overlay" id="rules-modal" onclick="this.style.display='none'">
        <div class="modal" onclick="event.stopPropagation()">
            <h3 id="modal-title">Game Over</h3>
            <p id="modal-msg">Score: 100</p>
            <button class="btn-primary" onclick="document.getElementById('rules-modal').style.display='none'">Close</button>
        </div>
    </div>

<script>
    // --- PREVENT SCROLLING LOGIC ---
    window.addEventListener("keydown", function(e) {
        // Space and arrow keys
        if([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
            // Only prevent if a game screen is active (not the hub)
            if(!document.getElementById('screen-hub').classList.contains('active')) {
                e.preventDefault();
            }
        }
    }, false);

    // --- MAIN SUITE CONTROLLER ---
    const Suite = {
        goHome: () => {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-hub').classList.add('active');
            SnakeGame.stop(); DinoGame.stop(); PacGame.stop();
            if(TTT.peer) { TTT.peer.destroy(); TTT.peer = null; }
        },
        loadGame: (id) => {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-' + id).classList.add('active');
            if(id === 'snake') SnakeGame.start();
            if(id === 'dino') DinoGame.draw();
            if(id === 'pacman') PacGame.start();
            if(id === 'ttt') TTT.showMenu();
        },
        showModal: (title, msg) => {
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-msg').innerHTML = msg;
            document.getElementById('rules-modal').style.display = 'flex';
        }
    };

    // --- 1. SNAKE GAME ---
    const SnakeGame = {
        canvas: document.getElementById('snake-canvas'),
        ctx: document.getElementById('snake-canvas').getContext('2d'),
        grid: 15, snake: {}, apple: {}, score: 0, running: false, interval: null,
        start: function() {
            this.snake = {x: 150, y: 150, dx: this.grid, dy: 0, cells: [], maxCells: 4};
            this.apple = {x: 60, y: 60};
            this.score = 0; this.running = true;
            document.getElementById('snake-score').innerText = 0;
            if(this.interval) clearInterval(this.interval);
            this.interval = setInterval(() => this.loop(), 100);
            document.addEventListener('keydown', this.handleInput.bind(this));
            this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
            this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
        },
        stop: function() { this.running = false; clearInterval(this.interval); },
        loop: function() {
            if(!this.running) return;
            this.ctx.clearRect(0,0, this.canvas.width, this.canvas.height);
            this.snake.x += this.snake.dx; this.snake.y += this.snake.dy;
            if(this.snake.x < 0) this.snake.x = this.canvas.width - this.grid;
            else if(this.snake.x >= this.canvas.width) this.snake.x = 0;
            if(this.snake.y < 0) this.snake.y = this.canvas.height - this.grid;
            else if(this.snake.y >= this.canvas.height) this.snake.y = 0;
            this.snake.cells.unshift({x: this.snake.x, y: this.snake.y});
            if(this.snake.cells.length > this.snake.maxCells) this.snake.cells.pop();
            this.ctx.fillStyle = '#DD8566'; this.ctx.fillRect(this.apple.x, this.apple.y, this.grid-1, this.grid-1);
            this.ctx.fillStyle = '#474D4D';
            this.snake.cells.forEach((cell, index) => {
                this.ctx.fillRect(cell.x, cell.y, this.grid-1, this.grid-1);
                if(index > 0 && cell.x === this.snake.cells[0].x && cell.y === this.snake.cells[0].y) {
                    this.stop(); Suite.showModal("Game Over", "Final Score: " + this.score);
                }
            });
            if(this.snake.cells[0].x === this.apple.x && this.snake.cells[0].y === this.apple.y) {
                this.snake.maxCells++; this.score += 10;
                document.getElementById('snake-score').innerText = this.score;
                this.apple.x = Math.floor(Math.random() * (this.canvas.width/this.grid)) * this.grid;
                this.apple.y = Math.floor(Math.random() * (this.canvas.height/this.grid)) * this.grid;
            }
        },
        handleInput: function(e) {
            if(e.which === 37 && this.snake.dx === 0) { this.snake.dx = -this.grid; this.snake.dy = 0; }
            else if(e.which === 38 && this.snake.dy === 0) { this.snake.dy = -this.grid; this.snake.dx = 0; }
            else if(e.which === 39 && this.snake.dx === 0) { this.snake.dx = this.grid; this.snake.dy = 0; }
            else if(e.which === 40 && this.snake.dy === 0) { this.snake.dy = this.grid; this.snake.dx = 0; }
        },
        xDown: null, yDown: null,
        handleTouchStart: function(evt) { this.xDown = evt.touches[0].clientX; this.yDown = evt.touches[0].clientY; },
        handleTouchMove: function(evt) {
            if (!this.xDown || !this.yDown) return;
            var xDiff = this.xDown - evt.touches[0].clientX; var yDiff = this.yDown - evt.touches[0].clientY;
            if (Math.abs(xDiff) > Math.abs(yDiff)) {
                if (xDiff > 0 && this.snake.dx===0) { this.snake.dx=-this.grid; this.snake.dy=0; } 
                else if (this.snake.dx===0) { this.snake.dx=this.grid; this.snake.dy=0; }
            } else {
                if (yDiff > 0 && this.snake.dy===0) { this.snake.dy=-this.grid; this.snake.dx=0; } 
                else if (this.snake.dy===0) { this.snake.dy=this.grid; this.snake.dx=0; }
            }
            this.xDown = null; this.yDown = null; evt.preventDefault();
        }
    };

    // --- 2. MINESWEEPER ---
    const MinesGame = {
        grid: [], rows: 10, cols: 10, mines: 15, gameOver: false,
        init: function(diff) {
            this.rows = diff==='hard'?14:10; this.cols = diff==='hard'?14:10; this.mines = diff==='hard'?35:12;
            this.gameOver = false;
            const board = document.getElementById('ms-board');
            board.style.gridTemplateColumns = `repeat(${this.cols}, 30px)`;
            board.innerHTML = '';
            this.grid = [];
            for(let r=0; r<this.rows; r++) {
                let row = [];
                for(let c=0; c<this.cols; c++) {
                    const el = document.createElement('div'); el.className = 'ms-cell';
                    el.onclick = () => this.click(r,c);
                    el.oncontextmenu = (e) => { e.preventDefault(); this.flag(r,c); };
                    let pressTimer; el.ontouchstart = () => { pressTimer = setTimeout(() => this.flag(r,c), 500); };
                    el.ontouchend = () => clearTimeout(pressTimer);
                    board.appendChild(el);
                    row.push({el: el, mine: false, revealed: false, flagged: false, neighbors: 0});
                }
                this.grid.push(row);
            }
            let minesPlaced = 0;
            while(minesPlaced < this.mines) {
                let r = Math.floor(Math.random()*this.rows); let c = Math.floor(Math.random()*this.cols);
                if(!this.grid[r][c].mine) { this.grid[r][c].mine = true; minesPlaced++; }
            }
            for(let r=0; r<this.rows; r++) for(let c=0; c<this.cols; c++) {
                if(this.grid[r][c].mine) continue;
                let count = 0;
                for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) if(r+i>=0 && r+i<this.rows && c+j>=0 && c+j<this.cols && this.grid[r+i][c+j].mine) count++;
                this.grid[r][c].neighbors = count;
            }
        },
        click: function(r,c) {
            if(this.gameOver || this.grid[r][c].flagged || this.grid[r][c].revealed) return;
            const cell = this.grid[r][c]; cell.revealed = true; cell.el.classList.add('revealed');
            if(cell.mine) {
                cell.el.classList.add('bomb'); cell.el.innerText = 'ðŸ’£'; this.gameOver = true;
                setTimeout(() => Suite.showModal("BOOM", "You hit a mine!"), 200);
            } else {
                if(cell.neighbors > 0) {
                    cell.el.innerText = cell.neighbors;
                    cell.el.style.color = ['#DD8566','#474D4D','#d35400','#2c3e50'][(cell.neighbors-1)%4];
                } else {
                    for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) if(r+i>=0 && r+i<this.rows && c+j>=0 && c+j<this.cols) this.click(r+i, c+j);
                }
            }
        },
        flag: function(r,c) {
            if(this.gameOver || this.grid[r][c].revealed) return;
            const cell = this.grid[r][c]; cell.flagged = !cell.flagged;
            cell.el.innerText = cell.flagged ? 'ðŸš©' : ''; cell.el.classList.toggle('flag');
        }
    };

    // --- 3. DINO RUN ---
    const DinoGame = {
        canvas: document.getElementById('dino-canvas'), ctx: document.getElementById('dino-canvas').getContext('2d'),
        running: false, dino: {x: 50, y: 150, w: 30, h: 30, dy: 0, grounded: true}, obstacles: [], frame: 0, score: 0, gravity: 0.8, speed: 6,
        start: function() {
            this.running = true; this.score = 0; this.frame = 0; this.obstacles = [];
            this.dino.y = 150; this.dino.dy = 0; this.speed = 6;
            document.getElementById('dino-start-btn').style.display = 'none';
            if(this.interval) clearInterval(this.interval);
            this.interval = setInterval(() => this.update(), 20);
            document.addEventListener('keydown', (e) => { if(e.code==='Space') this.jump(); });
            this.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); this.jump(); });
        },
        stop: function() {
            this.running = false; clearInterval(this.interval);
            document.getElementById('dino-start-btn').style.display = 'inline-block';
            document.getElementById('dino-start-btn').innerText = "Try Again";
        },
        jump: function() { if(this.dino.grounded) { this.dino.dy = -12; this.dino.grounded = false; } },
        update: function() {
            this.ctx.clearRect(0,0,600,200);
            this.dino.dy += this.gravity; this.dino.y += this.dino.dy;
            if(this.dino.y > 150) { this.dino.y = 150; this.dino.dy = 0; this.dino.grounded = true; }
            this.ctx.fillStyle = '#DD8566'; this.ctx.fillRect(this.dino.x, this.dino.y, this.dino.w, this.dino.h);
            this.ctx.beginPath(); this.ctx.moveTo(0, 180); this.ctx.lineTo(600, 180); this.ctx.strokeStyle = '#474D4D'; this.ctx.stroke();
            this.frame++;
            if(this.frame % 90 === 0) { this.obstacles.push({x: 600, w: 20, h: 30 + Math.random()*20}); this.speed += 0.1; }
            this.ctx.fillStyle = '#474D4D';
            this.obstacles.forEach((obs) => {
                obs.x -= this.speed; this.ctx.fillRect(obs.x, 180 - obs.h, obs.w, obs.h);
                if (this.dino.x < obs.x + obs.w && this.dino.x + this.dino.w > obs.x && this.dino.y < 180 && this.dino.y + this.dino.h > 180 - obs.h) {
                    this.stop(); Suite.showModal("Crashed!", "Score: " + Math.floor(this.score));
                }
            });
            this.score += 0.1; document.getElementById('dino-score').innerText = Math.floor(this.score);
        },
        draw: function() {
            this.ctx.clearRect(0,0,600,200); this.ctx.fillStyle = '#DD8566'; this.ctx.fillRect(50, 150, 30, 30);
            this.ctx.beginPath(); this.ctx.moveTo(0, 180); this.ctx.lineTo(600, 180); this.ctx.strokeStyle = '#474D4D'; this.ctx.stroke();
        }
    };

    // --- 4. PACMAN LITE (UPGRADED) ---
    const PacGame = {
        canvas: document.getElementById('pac-canvas'), ctx: document.getElementById('pac-canvas').getContext('2d'),
        grid: 16, pac: {x: 14, y: 23}, dir: {x: 0, y: 0}, nextDir: {x: 0, y: 0}, ghosts: [], dots: [], score: 0, running: false, interval: null, mouthOpen: true,
        map: [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],[1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],[1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],[1,0,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,0,1],[1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],[1,1,1,1,1,1,0,1,1,1,1,1,2,1,1,2,1,1,1,1,1,0,1,1,1,1,1,1],[1,1,1,1,1,1,0,1,1,1,1,1,2,1,1,2,1,1,1,1,1,0,1,1,1,1,1,1],[1,1,1,1,1,1,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,1,1,1,1,1,1],[1,1,1,1,1,1,0,1,1,2,1,1,1,2,2,1,1,1,2,1,1,0,1,1,1,1,1,1],[1,1,1,1,1,1,0,1,1,2,1,2,2,2,2,2,2,1,2,1,1,0,1,1,1,1,1,1],[2,2,2,2,2,2,0,2,2,2,1,2,2,2,2,2,2,1,2,2,2,0,2,2,2,2,2,2],[1,1,1,1,1,1,0,1,1,2,1,2,2,2,2,2,2,1,2,1,1,0,1,1,1,1,1,1],[1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1],[1,1,1,1,1,1,0,1,1,2,2,2,2,2,2,2,2,2,2,1,1,0,1,1,1,1,1,1],[1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1],[1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],[1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1],[1,0,0,0,1,1,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,1,1,0,0,0,1],[1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],[1,1,1,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],[1,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,0,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
        start: function() {
            this.pac={x:14,y:23}; this.dir={x:0,y:0}; this.nextDir={x:0,y:0}; this.score=0; this.running=true;
            document.getElementById('pac-score').innerText = '0';
            this.resetMap();
            this.ghosts = [{x:13,y:11,color:'#FF0000',type:0,dir:{x:0,y:0}}, {x:14,y:11,color:'#FFB8FF',type:1,dir:{x:0,y:0}}, {x:13,y:14,color:'#00FFFF',type:2,dir:{x:0,y:0}}, {x:14,y:14,color:'#FFB852',type:3,dir:{x:0,y:0}}];
            if(this.interval) clearInterval(this.interval); this.interval = setInterval(() => this.update(), 120);
            document.addEventListener('keydown', this.handleInput.bind(this));
            let tsX=0, tsY=0;
            this.canvas.addEventListener('touchstart', (e)=>{tsX=e.touches[0].clientX;tsY=e.touches[0].clientY;}, {passive:false});
            this.canvas.addEventListener('touchmove', (e)=>{e.preventDefault();}, {passive:false});
            this.canvas.addEventListener('touchend', (e)=>{
                const dx=e.changedTouches[0].clientX-tsX; const dy=e.changedTouches[0].clientY-tsY;
                if(Math.abs(dx)>Math.abs(dy)) this.nextDir=dx>0?{x:1,y:0}:{x:-1,y:0}; else this.nextDir=dy>0?{x:0,y:1}:{x:0,y:-1};
            });
        },
        stop: function() { this.running = false; clearInterval(this.interval); },
        resetMap: function() {
            for(let y=0;y<this.map.length;y++) for(let x=0;x<this.map[y].length;x++) if(this.map[y][x]===2 && !(y>=10&&y<=16&&x>=10&&x<=17)) this.map[y][x]=0;
        },
        handleInput: function(e) {
            if(!this.running) return;
            if(e.key==='ArrowUp') this.nextDir={x:0,y:-1}; else if(e.key==='ArrowDown') this.nextDir={x:0,y:1};
            else if(e.key==='ArrowLeft') this.nextDir={x:-1,y:0}; else if(e.key==='ArrowRight') this.nextDir={x:1,y:0};
        },
        isValidMove: function(x,y) { return y>=0 && y<this.map.length && x>=0 && x<this.map[0].length && this.map[y][x]!==1; },
        update: function() {
            if(!this.running) return;
            if(this.nextDir.x!==0||this.nextDir.y!==0) { if(this.isValidMove(this.pac.x+this.nextDir.x, this.pac.y+this.nextDir.y)) { this.dir=this.nextDir; this.nextDir={x:0,y:0}; } }
            let nx=this.pac.x+this.dir.x; let ny=this.pac.y+this.dir.y;
            if(nx<0) nx=this.map[0].length-1; if(nx>=this.map[0].length) nx=0;
            if(this.isValidMove(nx,ny)) { this.pac.x=nx; this.pac.y=ny; this.mouthOpen=!this.mouthOpen; }
            if(this.map[this.pac.y][this.pac.x]===0) {
                this.map[this.pac.y][this.pac.x]=2; this.score+=10; document.getElementById('pac-score').innerText=this.score;
                let dotsLeft=false; for(let r of this.map) if(r.includes(0)) dotsLeft=true;
                if(!dotsLeft) this.gameOver(true);
            }
            this.ghosts.forEach(g=>this.moveGhost(g));
            this.ghosts.forEach(g=>{ if(g.x===this.pac.x && g.y===this.pac.y) this.gameOver(false); });
            this.draw();
        },
        moveGhost: function(g) {
            let target={x:this.pac.x, y:this.pac.y};
            if(g.type===1) { target.x+=this.dir.x*4; target.y+=this.dir.y*4; }
            else if((g.type===2||g.type===3) && Math.random()>0.6) { target={x:Math.floor(Math.random()*this.map[0].length), y:Math.floor(Math.random()*this.map.length)}; }
            const dirs=[{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}];
            let validMoves=dirs.filter(d=>{
                if(g.dir.x!==0&&d.x===-g.dir.x) return false; if(g.dir.y!==0&&d.y===-g.dir.y) return false;
                const nx=g.x+d.x; const ny=g.y+d.y;
                return ny>=0&&ny<this.map.length&&nx>=0&&nx<this.map[0].length&&this.map[ny][nx]!==1;
            });
            if(validMoves.length===0) validMoves=dirs.filter(d=>{const nx=g.x+d.x;const ny=g.y+d.y; return ny>=0&&ny<this.map[0].length&&this.map[ny][nx]!==1;});
            if(validMoves.length>0) {
                validMoves.sort((a,b)=>{ const distA=Math.abs((g.x+a.x)-target.x)+Math.abs((g.y+a.y)-target.y); const distB=Math.abs((g.x+b.x)-target.x)+Math.abs((g.y+b.y)-target.y); return distA-distB; });
                let selected=validMoves[0];
                if(g.type>=2 && validMoves.length>1 && Math.random()<0.3) selected=validMoves[Math.floor(Math.random()*validMoves.length)];
                g.dir=selected; g.x+=selected.x; g.y+=selected.y;
            }
        },
        draw: function() {
            this.ctx.fillStyle='#000'; this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
            const cs=this.canvas.width/this.map[0].length;
            for(let y=0;y<this.map.length;y++) for(let x=0;x<this.map[y].length;x++) {
                if(this.map[y][x]===1) { this.ctx.fillStyle='#1919A6'; this.ctx.fillRect(x*cs+1,y*cs+1,cs-2,cs-2); }
                else if(this.map[y][x]===0) { this.ctx.fillStyle='#FFB8AE'; this.ctx.beginPath(); this.ctx.arc(x*cs+cs/2,y*cs+cs/2,2,0,Math.PI*2); this.ctx.fill(); }
            }
            const px=this.pac.x*cs+cs/2; const py=this.pac.y*cs+cs/2;
            this.ctx.fillStyle='#FFFF00'; this.ctx.beginPath();
            let rot=0; if(this.dir.x===-1)rot=Math.PI; if(this.dir.y===-1)rot=1.5*Math.PI; if(this.dir.y===1)rot=0.5*Math.PI;
            const ms=this.mouthOpen?0.2:0.05; this.ctx.arc(px,py,cs/2-1,rot+ms*Math.PI,rot+(2-ms)*Math.PI); this.ctx.lineTo(px,py); this.ctx.fill();
            this.ghosts.forEach(g=>{
                this.ctx.fillStyle=g.color; const gx=g.x*cs; const gy=g.y*cs;
                this.ctx.beginPath(); this.ctx.arc(gx+cs/2,gy+cs/2-2,cs/2-2,Math.PI,0); this.ctx.lineTo(gx+cs-2,gy+cs); this.ctx.lineTo(gx+2,gy+cs); this.ctx.fill();
                this.ctx.fillStyle='white'; this.ctx.beginPath(); this.ctx.arc(gx+cs/3,gy+cs/2-2,2,0,Math.PI*2); this.ctx.arc(gx+cs*2/3,gy+cs/2-2,2,0,Math.PI*2); this.ctx.fill();
            });
        },
        gameOver: function(won) {
            this.stop(); Suite.showModal(won?"YOU WON!":"GAME OVER", `Score: ${this.score}`);
        }
    };

    // --- 5. TIC TAC TOE SUITE ---
    const TTT = {
        mode: null, variant: null, peer: null, conn: null, difficulty: 'medium',
        board: [], turn: 'X', myPlayer: 'X', active: false,
        ultMacro: [], activeSubGrid: -1, scores: {p1:0, p2:0, draw:0},
        animationsEnabled: true, nextStarter: 'X', currentStarter: 'X',
        
        showMenu: () => {
            document.getElementById('ttt-menu').style.display='block';
            document.getElementById('ttt-mp-setup').style.display='none';
            document.getElementById('ttt-host-wait').style.display='none';
            document.getElementById('ttt-variant').style.display='none';
            document.getElementById('ttt-game').style.display='none';
            document.getElementById('ttt-bot-diff').style.display='none';
        },
        setup: (mode) => {
            TTT.mode = mode;
            if(mode === 'mp') {
                document.getElementById('ttt-menu').style.display='none';
                document.getElementById('ttt-mp-setup').style.display='block';
            } else if (mode === 'bot-diff') {
                document.getElementById('ttt-menu').style.display='none';
                document.getElementById('ttt-bot-diff').style.display='block';
            } else {
                TTT.mode = 'local';
                document.getElementById('ttt-menu').style.display='none';
                document.getElementById('ttt-variant').style.display='block';
            }
        },
        setDifficulty: (diff) => {
            TTT.difficulty = diff;
            TTT.mode = 'bot';
            document.getElementById('ttt-bot-diff').style.display='none';
            document.getElementById('ttt-variant').style.display='block';
        },
        startGame: (v) => {
            TTT.variant = v;
            document.getElementById('ttt-variant').style.display='none';
            document.getElementById('ttt-game').style.display='flex';
            TTT.initBoard();
        },
        initBoard: () => {
            TTT.active = true;
            TTT.turn = TTT.nextStarter; TTT.currentStarter = TTT.nextStarter;
            TTT.ultMacro = Array(9).fill(null); TTT.activeSubGrid = -1;
            
            document.getElementById('win-line-svg').innerHTML = '';
            
            document.getElementById('ttt-restart').style.display = 'none';
            document.getElementById('ttt-turn').innerText = `Turn: ${TTT.turn}`;
            const con = document.getElementById('ttt-board-container'); con.innerHTML = '';
            
            if(TTT.variant === 'normal') {
                TTT.board = Array(9).fill(null);
                const g = document.createElement('div'); g.id='board-normal';
                for(let i=0;i<9;i++) g.appendChild(TTT.cell(i)); con.appendChild(g);
            }
            if(TTT.variant === '3d') {
                TTT.board = Array(27).fill(null);
                const w = document.createElement('div'); w.id='board-3d';
                for(let z=0;z<3;z++){
                    const lb = document.createElement('div'); lb.className='level-container';
                    const lbl = document.createElement('div'); lbl.className='layer-label'; lbl.innerText=`Level ${z+1}`; lb.appendChild(lbl);
                    const l = document.createElement('div'); l.className='layer-3d';
                    for(let i=0;i<9;i++) l.appendChild(TTT.cell(z*9+i));
                    lb.appendChild(l); w.appendChild(lb);
                }
                con.appendChild(w);
            }
            if(TTT.variant === 'ultimate') {
                TTT.board = Array(81).fill(null);
                const g = document.createElement('div'); g.id='board-ultimate';
                for(let i=0;i<9;i++){
                    const s = document.createElement('div'); s.className='sub-grid active-zone'; s.id=`sub-${i}`;
                    for(let j=0;j<9;j++) s.appendChild(TTT.cell(i*9+j)); g.appendChild(s);
                }
                con.appendChild(g);
            }
            if(TTT.mode==='bot' && TTT.turn==='O') setTimeout(TTT.botMove, 800);
        },
        cell: (idx) => {
            const c = document.createElement('div'); c.className='ttt-cell';
            c.dataset.idx = idx; 
            
            // Add text span for rotation
            const s = document.createElement('span');
            c.appendChild(s);
            
            c.onclick = () => TTT.click(idx); return c;
        },
        click: (idx) => {
            if(!TTT.active || (TTT.mode!=='local' && TTT.turn!==TTT.myPlayer)) return;
            if(TTT.board[idx]) return;
            if(TTT.variant==='ultimate'){
                const s = Math.floor(idx/9);
                if(TTT.activeSubGrid!==-1 && s!==TTT.activeSubGrid) return;
                if(TTT.ultMacro[s]) return;
            }
            TTT.move(idx, TTT.turn);
            if(TTT.mode==='mp' && TTT.conn) TTT.conn.send({type:'move', idx:idx});
            if(TTT.mode==='bot' && TTT.active) setTimeout(TTT.botMove, 500);
        },
        move: (idx, p) => {
            TTT.board[idx] = p;
            let el;
            if(TTT.variant==='normal') el=document.querySelector(`#board-normal .ttt-cell[data-idx='${idx}']`);
            else if(TTT.variant==='3d') el=document.querySelector(`.layer-3d .ttt-cell[data-idx='${idx}']`);
            else el=document.querySelector(`#board-ultimate .ttt-cell[data-idx='${idx}']`);
            
            if(el) { 
                const s = el.querySelector('span') || el;
                s.innerText = p; 
                el.classList.add(p.toLowerCase()); 
            }
            
            let winLine = null;
            if(TTT.variant==='normal') winLine = TTT.checkWin(TTT.board, p);
            else if(TTT.variant==='3d') winLine = TTT.checkWin3D(TTT.board, p);
            else if(TTT.variant==='ultimate') winLine = TTT.handleUlt(idx, p);

            if(winLine) TTT.end(p, winLine);
            else if(TTT.board.every(c=>c)) TTT.end('draw', null);
            else {
                TTT.turn = TTT.turn==='X'?'O':'X';
                document.getElementById('ttt-turn').innerText = `Turn: ${TTT.turn}`;
                if(TTT.variant==='ultimate') TTT.highlightUlt();
            }
        },
        handleUlt: (idx, p) => {
            const s = Math.floor(idx/9);
            const sub = TTT.board.slice(s*9, s*9+9);
            if(TTT.checkWin(sub, p) && !TTT.ultMacro[s]) {
                TTT.ultMacro[s] = p;
                document.getElementById(`sub-${s}`).classList.add(p==='X'?'won-x':'won-o');
            }
            const next = idx % 9;
            TTT.activeSubGrid = (TTT.ultMacro[next] || TTT.board.slice(next*9, next*9+9).every(c=>c)) ? -1 : next;
            return TTT.checkWin(TTT.ultMacro, p);
        },
        highlightUlt: () => {
            for(let i=0;i<9;i++){
                const el = document.getElementById(`sub-${i}`); el.classList.remove('active-zone');
                if(!TTT.ultMacro[i] && (TTT.activeSubGrid===-1 || TTT.activeSubGrid===i)) el.classList.add('active-zone');
            }
        },
        checkWin: (b, p) => {
            const wins = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
            for(let w of wins) if(w.every(i => b[i]===p)) return w;
            return null;
        },
        checkWin3D: (b, p) => {
            const check = (s,d) => { 
                let line=[]; for(let i=0;i<3;i++) { if(b[s+i*d]!==p) return null; line.push(s+i*d); } 
                return line; 
            };
            let l;
            for(let i=0;i<9;i++) if(l=check(i,9)) return l;
            for(let z=0;z<3;z++) {
                for(let r=0;r<3;r++) if(l=check(z*9+r*3,1)) return l;
                for(let c=0;c<3;c++) if(l=check(z*9+c,3)) return l;
                if(l=check(z*9,4)) return l; if(l=check(z*9+2,2)) return l;
            }
            if(l=check(0,13)) return l; if(l=check(2,11)) return l;
            if(l=check(6,7)) return l; if(l=check(8,5)) return l;
            return null;
        },
        botMove: () => {
            let moves=[]; 
            TTT.board.forEach((c,i)=>{ if(!c) moves.push(i) });
            
            // Ultimate restriction
            if(TTT.variant==='ultimate') {
                moves = moves.filter(i => { 
                    const s = Math.floor(i/9); 
                    return TTT.activeSubGrid===-1 || TTT.activeSubGrid===s; 
                });
            }

            if (moves.length === 0) return;

            let chosen = moves[0];

            // --- DIFFICULTY LOGIC ---
            if (TTT.difficulty === 'easy') {
                // Completely Random
                chosen = moves[Math.floor(Math.random() * moves.length)];
            } 
            else if (TTT.difficulty === 'medium') {
                // 60% chance to be smart, 40% random
                if (Math.random() > 0.4) {
                    chosen = TTT.getBestMove(moves, 'medium');
                } else {
                    chosen = moves[Math.floor(Math.random() * moves.length)];
                }
            } 
            else {
                // Hard: 100% Minimax
                chosen = TTT.getBestMove(moves, 'hard');
            }

            TTT.move(chosen, 'O');
        },
        getBestMove: (availableMoves, level) => {
            // For Ultimate or 3D, full minimax is too slow without optimization.
            // Fallback to simple lookahead for complex variants to prevent browser freeze.
            if (TTT.variant !== 'normal') {
                // Win if can, Block if must
                for (let m of availableMoves) {
                    let temp = [...TTT.board]; temp[m] = 'O';
                    if (TTT.checkWinSim(temp, 'O')) return m;
                }
                for (let m of availableMoves) {
                    let temp = [...TTT.board]; temp[m] = 'X';
                    if (TTT.checkWinSim(temp, 'X')) return m;
                }
                return availableMoves[Math.floor(Math.random() * availableMoves.length)];
            }

            // Standard Minimax for 3x3
            let bestScore = -Infinity;
            let move = availableMoves[0];
            
            for (let i = 0; i < availableMoves.length; i++) {
                let idx = availableMoves[i];
                TTT.board[idx] = 'O';
                let score = TTT.minimax(TTT.board, 0, false);
                TTT.board[idx] = null;
                if (score > bestScore) {
                    bestScore = score;
                    move = idx;
                }
            }
            return move;
        },
        minimax: (board, depth, isMax) => {
            let winLine = TTT.checkWin(board, isMax ? 'X' : 'O');
            if (TTT.checkWin(board, 'O')) return 10 - depth;
            if (TTT.checkWin(board, 'X')) return depth - 10;
            if (board.every(c => c)) return 0;

            if (isMax) {
                let best = -Infinity;
                for (let i = 0; i < 9; i++) {
                    if (!board[i]) {
                        board[i] = 'O';
                        best = Math.max(best, TTT.minimax(board, depth + 1, false));
                        board[i] = null;
                    }
                }
                return best;
            } else {
                let best = Infinity;
                for (let i = 0; i < 9; i++) {
                    if (!board[i]) {
                        board[i] = 'X';
                        best = Math.min(best, TTT.minimax(board, depth + 1, true));
                        board[i] = null;
                    }
                }
                return best;
            }
        },
        checkWinSim: (b, p) => {
            if(TTT.variant==='normal') return TTT.checkWin(b,p);
            if(TTT.variant==='3d') return TTT.checkWin3D(b,p);
            return false; 
        },
        end: (res, winLine) => {
            TTT.active = false;
            document.getElementById('ttt-turn').innerText = res==='draw'?"Draw!":`${res} Wins!`;
            
            if(res==='draw') {
                TTT.scores.draw++;
                TTT.nextStarter = TTT.currentStarter === 'X' ? 'O' : 'X';
            } else {
                if(res==='X') TTT.scores.p1++; else TTT.scores.p2++;
                TTT.nextStarter = res==='X'?'O':'X';
            }
            document.getElementById('p1-score').innerText = `P1: ${TTT.scores.p1}`;
            document.getElementById('p2-score').innerText = `P2: ${TTT.scores.p2}`;

            // Draw line if enabled and won
            if(res !== 'draw' && winLine) {
                 TTT.drawWinLine(winLine);
            }
            setTimeout(() => document.getElementById('ttt-restart').style.display='block', 800);
        },
        drawWinLine: (indices) => {
            if(!indices || indices.length===0 || TTT.variant==='ultimate') return;
            const startIdx = indices[0]; const endIdx = indices[indices.length-1];
            
            const getCenter = (idx) => {
                let el;
                if(TTT.variant==='normal') el=document.querySelector(`#board-normal .ttt-cell[data-idx='${idx}']`);
                else el=document.querySelector(`.layer-3d .ttt-cell[data-idx='${idx}']`);
                
                if(!el) return {x:0,y:0};
                
                const r = el.getBoundingClientRect();
                const wr = document.getElementById('game-wrapper').getBoundingClientRect();
                return { x: r.left+r.width/2 - wr.left, y: r.top+r.height/2 - wr.top };
            };
            const s = getCenter(startIdx); const e = getCenter(endIdx);
            const path = document.createElementNS('http://www.w3.org/2000/svg','path');
            path.setAttribute('d', `M ${s.x} ${s.y} L ${e.x} ${e.y}`);
            path.setAttribute('class', 'win-path');
            document.getElementById('win-line-svg').appendChild(path);
        },
        restart: () => { TTT.initBoard(); },
        
        // Multiplayer Logic
        makeId: (l) => { const c='ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; let r=''; for(let i=0;i<l;i++) r+=c.charAt(Math.floor(Math.random()*c.length)); return r; },
        
        host: () => {
            document.getElementById('ttt-mp-setup').style.display='none';
            document.getElementById('ttt-host-wait').style.display='block';
            const hostId = TTT.makeId(9);
            TTT.peer = new Peer(hostId, {config:{'iceServers':[{url:'stun:stun.l.google.com:19302'}]}});
            TTT.peer.on('open', id => document.getElementById('host-code').innerText=id);
            TTT.peer.on('connection', c => {
                TTT.conn = c; TTT.setupConn();
                document.getElementById('host-status').innerText = "Connected!";
                setTimeout(() => {
                    TTT.conn.send({type:'start', v:'normal'}); 
                    TTT.startGame('normal');
                }, 1000);
            });
        },
        join: () => {
            const code = document.getElementById('join-code').value.trim().toUpperCase();
            if(!code || code.length !== 9) return alert("Code must be exactly 9 characters.");
            
            TTT.peer = new Peer(null, {config:{'iceServers':[{url:'stun:stun.l.google.com:19302'}]}});
            TTT.peer.on('open', () => {
                TTT.conn = TTT.peer.connect(code);
                TTT.setupConn();
            });
            TTT.peer.on('error', () => alert("Connection failed. Check code or network."));
        },
        setupConn: () => {
            TTT.conn.on('data', d => {
                if(d.type==='start'){ TTT.myPlayer='O'; TTT.startGame(d.v); }
                if(d.type==='move') TTT.move(d.idx, TTT.myPlayer==='X'?'O':'X');
            });
        },
        copyLink: () => {
            const id = document.getElementById('host-code').innerText;
            if(id === 'Generating...') return;
            const link = window.location.origin + window.location.pathname + '?join=' + id;
            navigator.clipboard.writeText(link).then(() => {
                const t = document.getElementById('toast'); t.className = "show";
                setTimeout(() => { t.className = t.className.replace("show", ""); }, 3000);
            });
        }
    };

    // Auto-Join Link Logic
    window.addEventListener('DOMContentLoaded', () => {
        const urlParams = new URLSearchParams(window.location.search);
        const joinCode = urlParams.get('join');
        if (joinCode) {
            Suite.loadGame('ttt');
            TTT.setup('mp');
            document.getElementById('join-code').value = joinCode;
        }
    });
    document.getElementById('anim-toggle').addEventListener('change', (e) => TTT.animationsEnabled = e.target.checked);
</script>
</body>
</html>
